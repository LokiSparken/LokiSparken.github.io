---
title: 【UE4】花式导入 DLL（一）
categories:
  - - Unreal Engine
tags:
  - UE4
  - configuration
  - null
date: 2020-10-13 23:59:16
ACM:
---

## 一、配置环境
* Windows 10
* Unreal Engine 4.24
* Visual Studio 2017

<!-- more -->

## 二、创建一个简单的 DLL 库
* VS2017 新建项目 `Windows 控制台应用程序 ConsoleApplication - DLLProducer1`
* 修改项目配置属性
  * 平台：`x64`
  * 项目 - 属性 - 配置属性 - 常规 - 配置类型：`dll`
* 创建头文件、源文件 `DLLProducer1.h`、`DLLProducer1.cpp`
	```cpp
	// .h
	#pragma once
	#define DLL_EXPORT __declspec(dllexport)
	#ifdef __cplusplus
	extern "C"
	{
		#endif	
		float DLL_EXPORT getCircleArea(float radius);
		#ifdef __cplusplus
	}
	#endif
	```

	```cpp
	// .cpp
	#include "DLLProducer1.h"
	float DLL_EXPORT getCircleArea(float radius)
	{
		return (3.14 * (radius * radius));
	}
	```
* F7 编译，在 x64 目录下得到 `.dll`

## 三、在 UE 4.24 中导入（1）蓝图可调用
* 将 `.dll` 加入到 UE4 工程
  * 在 UE4 项目文件根目录下新建文件夹 Plugins
  * 复制 `.dll` 到 Plugins
* 创建UE4项目的新C++类 `DLLInvokeTest`
  * New C++ Class
  * 父类 `Blueprint Function Library`
* 头文件
	```cpp
	// DLLInvokeTest.h
	UCLASS()
	class DLLTEST_API UDLLTest : public UBlueprintFunctionLibrary
	{
		GENERATED_BODY()
	public:
		UDLLTest();

		// 声明加载 DLL 的函数
		UFUNCTION(BlueprintCallable, Category = "MyDllInvokeTest")
		static bool importDll(FString folder, FString name);
		
		// 声明导入 DLL 库中具体函数的方法
		UFUNCTION(BlueprintCallable, Category = "MyDllInvokeTest")
		static bool importMethodGetCircleAreaFromDll();

		// 声明从 DLL 引入函数后的调用接口
		UFUNCTION(BlueprintCallable, Category = "MyDllInvokeTest")
		static float getCircleArea(float radius);
	};
	```
* 源文件
	```cpp
	// DLLInvokeTest.cpp
	#include "DLLInvokeTest.h"
	#include "Runtime/Core/Public/Misc/Paths.h"		// using FPaths
	#include "Runtime/Core/Public/HoloLens/HoloLensPlatformProcess.h"	// using FPlatformProcess

	// 1. 声明用于存储相应 DLL 函数的方法
	typedef float(*_getCircleArea)(float radius);

	// 2. 加载 DLL 库
	void *dllHandle;
	bool UDLLTest::importDll(FString folder, FString name)
	{
		// *FPaths::GamePluginsDir() 为项目插件目录，若使用引擎目录则为EnginePluginsDir()
		FString filePath = *FPaths::GamePluginsDir() + folder + "/" + name;

		if (FPaths::FileExists(filePath))
		{
			// 获取DLL库
			dllHandle = FPlatformProcess::GetDllHandle(*filePath);
			if (dllHandle != NULL)
			{
				return true;
			}
		}
		return false;
	}

	// 3. 从 DLL 库中导入具体的函数
	_getCircleArea m_getCircleAreaFromDll;   // 创建实例
	bool UDLLTest::importMethodGetCircleAreaFromDll()
	{
		if (dllHandle != NULL)
		{
			m_getCircleAreaFromDll = NULL;
			FString procName = "getCircleArea";	// DLL 库中的函数名，严格对应
			m_getCircleAreaFromDll = (_getCircleArea)FPlatformProcess::GetDllExport(dllHandle, *procName);
			if (m_getCircleAreaFromDll != NULL)
			{
				return true;
			}
		}
		return false;
	}

	// 4. 供调用的接口
	float UDLLTest::getCircleArea(float radius)
	{
		if (m_getCircleAreaFromDll != NULL)
		{
			float out = m_getCircleAreaFromDll(radius); // 调用
			UE_LOG(LogTemp, Warning, TEXT("Successly call method <getCircleAreaFromDll> from DLL library."));
			return out;
		}
		UE_LOG(LogTemp, Warning, TEXT("Failed to call method <getCircleAreaFromDll> from DLL library."));
		return 1.0f;
	}

	// 在该类构造期间就加载DLL库及相关函数
	UDLLTest::UDLLTest()
	{
		// 调用 DLL 库的加载函数
		if (importDll("DLL", "DLLProducer1.dll"))
		{
			UE_LOG(LogTemp, Warning, TEXT("DLL load ok."));
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("DLL load failed."));
		}
		// 调用函数导入
		if (importMethodGetCircleAreaFromDll())
		{
			UE_LOG(LogTemp, Warning, TEXT("method <getCircleArea> load ok."));
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("method <getCircleArea> load failed."));
		}
	}
	```
* 新建蓝图，在 Event Graph 中即可调用 `getCircleArea()` 函数

> <i class="fa fa-question fa-x"></i> 问题：
> * 可能和 UE4 耦合度略高，测自定义类型的时候 UE4 总会报错提示需要其为 UE4 类型。  
> * （当然后来发现实际上也可能是库的依赖问题导致加载 DLL 就失败，只是 UE4 报错总会口胡（逃

## 四、在 UE 4.24 中导入（2）纯净 C++ 版
> <i class="fa fa-exclamation fa-x"></i> 注意：
> * 以下可忽略，与（1）基本相同，只是把继承自 UE4 类的相关部分剥离
* 将 `.dll` 加入到 UE4 工程
  * 在 UE4 项目文件根目录下新建文件夹 Plugins
  * 复制 `.dll` 到 Plugins
* 创建UE4项目的新C++类 `DLLImporter`
  * New C++ Class
  * 父类 `None`
* 头文件
	```cpp
	// DLLImporter.h
	typedef double(*_getCircleAreaFromDll)(double radius);

	class DLLTEST_API DLLImporter
	{
	private:
		void *dllHandle, *dllHandleForPackage;
		_getCircleAreaFromDll m_getCircleAreaFromDll;

	public:
		DLLImporter();
		~DLLImporter();

		bool importDLL(FString folder, FString name);
		bool importDLLForPackage();
		bool importMethodGetCircleAreaFromDll();
		double getCircleArea(double radius);
	};
	```

* 源文件

	```cpp
	// DLLImporter.cpp
	#include "DLLImporter.h"
	#include "Runtime/Engine/Public/EngineGlobals.h"	// using GEngine

	DLLImporter::DLLImporter()
	{
		// 加载
		if (importDLL("DLL", "DLLProducer1.dll"))
		{
			// 导入
			if (importMethodGetCircleAreaFromDll())
			{
				// 调用
				double ans = getCircleArea(1.0);
				UE_LOG(LogTemp, Warning, TEXT("method calling result: %f"), ans);
				UE_LOG(LogTemp, Warning, TEXT(" "));
			}
			else
			{
				UE_LOG(LogTemp, Warning, TEXT("method <getCircleArea> load failed."));
			}			
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("DLL <DLLProducer1.dll> load failed."));
		}
	}

	bool DLLImporter::importDLL(FString folder, FString name)
	{
		FString filePath = *FPaths::GamePluginsDir() + folder + "/" + name;
		if (FPaths::FileExists(filePath))
		{
			dllHandle = FPlatformProcess::GetDllHandle(*filePath);
			if (dllHandle != NULL)
			{
				return true;
			}
		}
		return false;
	}

	bool DLLImporter::importMethodGetCircleAreaFromDll()
	{
		if (dllHandle != NULL)
		{
			m_getCircleAreaFromDll = NULL;
			FString procName = "getCircleArea";
			m_getCircleAreaFromDll = (_getCircleAreaFromDll)FPlatformProcess::GetDllExport(dllHandle, *procName);
			if (m_getCircleAreaFromDll != NULL)
			{
				return true;
			}
		}
		return false;
	}

	double DLLImporter::getCircleArea(double radius)
	{
		if (m_getCircleAreaFromDll != NULL)
		{
			double out = m_getCircleAreaFromDll(radius);
			UE_LOG(LogTemp, Warning, TEXT("Successly call method <getCircleArea> from DLL library."));
			return out;
		}
		UE_LOG(LogTemp, Warning, TEXT("m_getCircleAreaFromDll NULL! Failed to call method <getCircleArea> from DLL library."));
		return 1.0;
	}

	```